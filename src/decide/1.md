- Let M be an arbitrary Turing machine.

  ```kotlin
  val M: TM = { w: Input -> TODO() }
  ```

  (a) Describe a Turing machine N: Accept(N) = Reject(M) and Reject(N) = Accept(M).

  ```kotlin
  val N: TM = { w: Input -> !M(w) }
  ```

  We see that Accept(N) = {w : M(w) == false} = Reject(M). And Reject(N) = {w : M(w) == true} = Accept(M).

  (b) Describe a Turing machine N: Accept(N) = Accept(M) and Reject(N) = EMPTY.

  ```kotlin
  val N: TM = { w: Input ->
  	if (M(w)) true
  	else loop()
  }
  ```

  We see that Accept(N) = Accept(M). And in all other cases, N will hang and reject nothing.

  (c) Describe a Turing machine N: Accept(N) = Halt(M) and Reject(N) = EMPTY.

  ```kotlin
  val N: TM = { w: Input ->
  	M(w)
  	true
  }
  ```

  We see that N accepts w iff. M halts. And N does not reject input (either accept or hang).

- (a) Prove that Accept is undecidable.

  Suppose a Turing Machine Acc decides Accept.

  ```kotlin
  val Acc: TM2 = { M: TuringMachine, w: Input -> TODO() }
  ```

  Now we construct another Turing Machine N as follows:

  ```{kotlin}
  val N: TM = { w: Input -> !Acc(N, w) }
  ```

  We see that N accepts w iff. Acc(N, w) == false, i.e. N rejects w. This is a contradiction.

  (b) Prove that Reject is undecidable.

  Suppose a Turing Machine Rej decides Reject.

  ```kotlin
  val Rej: TM2 = { M: TuringMachine, w: Input -> TODO() }
  ```

  Now we construct another Turing Machine N as follows:

  ```kotlin
  val N: TM = { w: Input -> Rej(N, w) }
  ```

  We see that N rejects w iff. Rej(N, w) == false, i.e. N does NOT reject w. This is a contradiction.

  (c) Prove that Diverge is undecidable

  Suppose a Turing Machine Div decides Diverge.

  ```kotlin
  val Div: TM2 = { M: TuringMachine, w: Input -> TODO() }
  ```

  We construct another Turing Machine N as follows:

  ```kotlin
  val N: TM = { w: Input ->
  	if (Div(N, w)) halt()
  	else loop()
  }
  ```

  We see that N halts iff. Div(N, w) == true, i.e. N hangs on w, i.e. N does NOT halt on w. This is a contradiction.