- Let M be an arbitrary Turing machine.

  ```kotlin
  val M: TM = { w: Input -> TODO() }
  ```

  (a) Describe a Turing machine N: Accept(N) = Reject(M) and Reject(N) = Accept(M).

  ```kotlin
  val N: TM = { w: Input -> !M(w) }
  ```

  We see that Accept(N) = {w : M(w) == false} = Reject(M). And Reject(N) = {w : M(w) == true} = Accept(M).

  (b) Describe a Turing machine N: Accept(N) = Accept(M) and Reject(N) = EMPTY.

  ```kotlin
  val N: TM = { w: Input ->
  	if (M(w)) return true
  	else loop()
  }
  ```

  We see that Accept(N) = Accept(M). And in all other cases, N will hang and reject nothing.

  (c) Describe a Turing machine N: Accept(N) = Halt(M) and Reject(N) = EMPTY.

  ```kotlin
  val N: TM = { w: Input ->
  	M(w)
  	return true
  }
  ```

  We see that N accepts w iff. M halts. And N does not reject input (either accept or hang).

- (a) Prove that Accept is undecidable.

  Suppose a Turing Machine Acc decides Accept.

  ```kotlin
  val Acc: TM2 = { M: TuringMachine, w: Input -> TODO() }
  ```

  Now we construct another Turing Machine N as follows:

  ```{kotlin}
  val N: TM = { w: Input -> !Acc(N, w) }
  ```

  We see that N accepts w iff. Acc(N, w) == false, i.e. N rejects w. This is a contradiction.

  (b) Prove that Reject is undecidable.

  Suppose a Turing Machine Rej decides Reject.

  ```kotlin
  val Rej: TM2 = { M: TuringMachine, w: Input -> TODO() }
  ```

  Now we construct another Turing Machine N as follows:

  ```kotlin
  val N: TM = { w: Input -> Rej(N, w) }
  ```

  We see that N rejects w iff. Rej(N, w) == false, i.e. N does NOT reject w. This is a contradiction.

  (c) Prove that Diverge is undecidable

  Suppose a Turing Machine Div decides Diverge.

  ```kotlin
  val Div: TM2 = { M: TuringMachine, w: Input -> TODO() }
  ```

  We construct another Turing Machine N as follows:

  ```kotlin
  val N: TM = { w: Input ->
  	if (Div(N, w)) halt()
  	else loop()
  }
  ```

  We see that N halts iff. Div(N, w) == true, i.e. N hangs on w, i.e. N does NOT halt on w. This is a contradiction.

- (a) Prove that NeverReject is undecidable.

	Suppose a Turing Machine NR decides NeverReject.

	```kotlin
	val NR: TMD = { M: TM -> TODO() }
	```

	Then we can solve the halting problem as:

	```kotlin
	val Halt: TM2 = { M: TM, w: Input ->
		val N = { x: Input ->
	    	M(w)
	        return x != "random string"
	    }
	    return !NR(N)
	}
	```

	I claim that M halts on w iff. !NR(N) == true, i.e. NR(N) == false, i.e. N does reject some input x.

	- Suppose M halts on w. Then N rejects "random string".
	- Suppose M does NOT halt on w. Then N hangs on every input x and thus reject nothing, i.e. NR(N) == true.

	(b) Prove that NeverHalt is undecidable.

	Suppose a Turing Machine NH decides NeverHalt.

	```kotlin
	val NH: TMD = { M: TM -> TODO() }
	```

	Then we can solve the halting problem as:

	```kotlin
	val Halt: TM2 = { M: TM, w: Input ->
		val N = { x: Input ->
	    	M(w)
	        halt()
	    }
	    return !NH(N)
	}
	```

	I claim that M halts on w iff. NH(N) == false.

	- Suppose M halts on w. Then N halts on every input x. So NH(N) == false.
	- Suppose M does NOT halt on w. Then N does NOT halt on every input x. Therefore, NH(N) == true as desired.

	(c) Prove that NeverDiverge is undecidable.

	Suppose a Turing Machine ND decides NeverDiverge.

	```kotlin
	val ND: TMD = { M: TM -> TODO() }
	```

	Then we can solve the halting problem as:

	```kotlin
	val Halt: TM2 = { M: TM, w: Input ->
		val N = { x: Input ->
	    	M(w)
	        halt()
	    }
	    return ND(N)
	}
	```

	I claim that M halts on w iff. ND(N) == true.

	- Suppose M halts on w. Then N halts on every input x. So ND(N) == true.
	- Suppose M does NOT halt on w. Then N does NOT halt on any input x. Since N diverges on all input x indeed, ND(N) = false.