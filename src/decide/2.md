- For each of the following decision problems, either sketch an algorithm or prove that theproblem is undecidable. Recall that w^R denotes the reversal of string w. For each problem,the input is the encoding <M> of a Turing machine M.

	(a) Does M reject the empty string?

	We can prove by Rice's Reject Theorem. Let P = {languages containing empty string, e}

	Consider `Y: TM = { w: Input -> return w.isNotEmpty() }` and N = M_ACC.

	We see that Reject(Y) = {e}, which is in P. And Reject(N) = EMPTY, which is NOT in P. Therefore, {<M> : Reject(M) in P} is undecidable. 

	(b) Does M accept <M>^R?

	Suppose MR decides if M accepts <M>^R. We can solve the halting problem as follows:

	```kotlin
	val Halt: TM2 = { M: TM, w: Input ->
		val N = { x: Input ->
	  		M(w)
	        true
	    }
	    MR(N)
	}
	```

	I claim that M halts on w iff. MR(N) == true, i.e. N accepts <N>^R.

	- Suppose M halts on w. Then N accepts all input. More specifically, N accepts <N>^R.
	- Suppose M does NOT halt on w. Then N does NOT accept any input. More specifically, N does NOT accept <N>^R, i.e. MR(N) == false.

	(c) Does M accept <M><M>?

	Similar proof as shown in (b).

	(d) Does M accept <M>^k for any integer k?

	Similar proof as shown in (b).

	(e) Does M accept the encoding of any Turing machine?

	We can prove by Rice's Theorem. Let P = {languages containing any Turing machine encodings}.

	Consider `Y: TMD = { M: TM -> true }` and N = M_REJ.

	We see that Accept(Y) is all Turing machines, which is in P. (Otherwise, we will go into runtime error. This is just a trick for checking valid Turing machines). And Accept(N) = EMPTY, which is NOT in P. Therefore deciding whether a Turing machine accepts any Turing machine encodings is undecidable.

	(f) Is there a Turing machine that accepts <M>?

	Sure. M_ACC accepts <M> since it accepts any Input.

	(g) Is <M> a palindrome?

	Given <M> as Input, which is just a String, we can easily check whether it is a palindrome in O(n) time.

	```kotlin
	fun Encoding.isPalindrome(): Boolean {
	    var start = 0
	    var end = length
	    if (end <= 1) {
	        return true
	    }
	    
	    while (start < end) {
	        if (this[start] != this[end]) {
	            return false
	        }
	        start++
	        end--
	    }
	    return true
	}
	```

	(h) Does M reject any palindrome?

	​

	(i) Does M accept all palindromes?

	​

	(j) Does M diverge only on palindromes?

	​

	(k) Is there an input string that forces M to move left?

	​

	(l) Is there an input string that forces M to move left three times in a row?

	​

	(m) Does M accept the encoding of any Turing machine N: Accept(N) = SelfDiverge?